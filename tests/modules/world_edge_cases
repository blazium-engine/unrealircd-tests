#!/usr/bin/python3
"""
World Module - Edge Cases Test
Tests error conditions, boundary scenarios, and edge cases
"""

import irctestframework.irctest
import time

m = irctestframework.irctest.IrcTest()
c1a = m.new('c1a')
c1b = m.new('c1b')
c1c = m.new('c1c')
m.connect()

print("=" * 60)
print("WORLD MODULE - EDGE CASES TESTS")
print("=" * 60)
print(f"Test suite started at: {time.strftime('%Y-%m-%d %H:%M:%S')}")
print()

# Setup: Request capability
m.send(c1a, "CAP REQ :world/features")
resp = m.expect(c1a, "Capability response", ".*ACK.*world/features|.*NAK.*world/features")
if "NAK" in str(resp):
    print("SKIP: World module not loaded - capability NAK'd")
    print("All edge case tests skipped - module not available")
    exit(0)
m.clearlog()

# Setup other clients
m.send(c1b, "CAP REQ :world/features")
m.expect(c1b, "Capability acknowledged", ".*ACK.*world/features")
m.clearlog()

m.send(c1c, "CAP REQ :world/features")
m.expect(c1c, "Capability acknowledged", ".*ACK.*world/features")
m.clearlog()

# Join world channel
m.send(c1a, "JOIN #spawn")
m.send(c1b, "JOIN #spawn")
m.send(c1c, "JOIN #spawn")
m.clearlog()

# Test 1: Movement while not in world
print("[TEST] Movement while not in world")
m.send(c1a, "MOVE north")
m.expect(c1a, "Error: not in world", ":.*2241.*")
m.clearlog()
print()

# Test 2: Join world first
print("[TEST] Join world first")
m.send(c1a, "WORLD join")
m.expect(c1a, "World join success", ":.*2200.*")
m.expect(c1a, "User mode +y set", "MODE.*\\+y")
m.clearlog()
print()

# Test 3: Invalid movement direction
print("[TEST] Invalid movement direction")
m.send(c1a, "MOVE invalid")
m.expect(c1a, "Error: invalid direction", ":.*2242.*")
m.clearlog()

m.send(c1a, "MOVE diagonal")
m.expect(c1a, "Error: invalid direction", ":.*2242.*")
m.clearlog()

m.send(c1a, "MOVE")
m.expect(c1a, "Error: missing direction", ":.*2242.*")
m.clearlog()
print()

# Test 4: Movement beyond world boundaries
print("[TEST] Movement beyond world boundaries")
# Move to edge of world (assuming 10x10 world)
for i in range(15):  # Try to move beyond boundaries
    m.send(c1a, "MOVE north")
    resp = m.expect(c1a, f"Move attempt {i+1}", ":.*2210.*|:.*2243.*")
    if ":.*2243.*" in str(resp):  # Boundary hit
        break
m.clearlog()

# Try moving in other directions beyond boundaries
m.send(c1a, "MOVE west")
resp = m.expect(c1a, "West boundary test", ":.*2210.*|:.*2243.*")
m.clearlog()

m.send(c1a, "MOVE south")
resp = m.expect(c1a, "South boundary test", ":.*2210.*|:.*2243.*")
m.clearlog()

m.send(c1a, "MOVE east")
resp = m.expect(c1a, "East boundary test", ":.*2210.*|:.*2243.*")
m.clearlog()
print()

# Test 5: Rapid command spam (rate limit validation)
print("[TEST] Rapid command spam - rate limit validation")
log_info("Testing rate limiting with rapid commands")

# Send many MOVE commands rapidly
for i in range(20):
    m.send(c1a, "MOVE north")
    resp = m.expect(c1a, f"Rapid move {i+1}", ":.*2210.*|:.*2244.*")
    if ":.*2244.*" in str(resp):  # Rate limit hit
        log_info(f"Rate limit hit after {i+1} commands")
        break
m.clearlog()
print()

# Test 6: Concurrent movements from multiple users
print("[TEST] Concurrent movements from multiple users")
# Join other users to world
m.send(c1b, "WORLD join")
m.expect(c1b, "c1b world join", ":.*2200.*")
m.clearlog()

m.send(c1c, "WORLD join")
m.expect(c1c, "c1c world join", ":.*2200.*")
m.clearlog()

# Move all users simultaneously
m.send(c1a, "MOVE north")
m.send(c1b, "MOVE south")
m.send(c1c, "MOVE east")

# Each should see their own success and others' movements
m.expect(c1a, "c1a move success", ":.*2210.*")
m.expect(c1a, "c1a sees c1b move", "WORLD.*MOVE")
m.expect(c1a, "c1a sees c1c move", "WORLD.*MOVE")

m.expect(c1b, "c1b move success", ":.*2210.*")
m.expect(c1b, "c1b sees c1a move", "WORLD.*MOVE")
m.expect(c1b, "c1b sees c1c move", "WORLD.*MOVE")

m.expect(c1c, "c1c move success", ":.*2210.*")
m.expect(c1c, "c1c sees c1a move", "WORLD.*MOVE")
m.expect(c1c, "c1c sees c1b move", "WORLD.*MOVE")

m.clearlog()
print()

# Test 7: Channel without world config
print("[TEST] Channel without world config")
m.send(c1a, "JOIN #regular")
m.clearlog()

m.send(c1a, "WORLD join")
m.expect(c1a, "Error: not a world channel", ":.*2245.*")
m.clearlog()

# Return to world channel
m.send(c1a, "JOIN #spawn")
m.clearlog()
print()

# Test 8: Malformed WORLD commands
print("[TEST] Malformed WORLD commands")
m.send(c1a, "WORLD")
m.expect(c1a, "Error: missing subcommand", ":.*2246.*")
m.clearlog()

m.send(c1a, "WORLD invalid")
m.expect(c1a, "Error: invalid subcommand", ":.*2246.*")
m.clearlog()

m.send(c1a, "WORLD join extra")
m.expect(c1a, "Error: too many parameters", ":.*2246.*")
m.clearlog()

m.send(c1a, "WORLD part extra")
m.expect(c1a, "Error: too many parameters", ":.*2246.*")
m.clearlog()

m.send(c1a, "WORLD show extra")
m.expect(c1a, "Error: too many parameters", ":.*2246.*")
m.clearlog()
print()

# Test 9: FACE with invalid direction
print("[TEST] FACE with invalid direction")
m.send(c1a, "FACE invalid")
m.expect(c1a, "Error: invalid direction", ":.*2247.*")
m.clearlog()

m.send(c1a, "FACE")
m.expect(c1a, "Error: missing direction", ":.*2247.*")
m.clearlog()

m.send(c1a, "FACE diagonal")
m.expect(c1a, "Error: invalid direction", ":.*2247.*")
m.clearlog()
print()

# Test 10: Teleportation with missing entrance/exit
print("[TEST] Teleportation with missing entrance/exit")
# Try to teleport to non-existent world
m.send(c1a, "WORLD teleport nonexistent")
m.expect(c1a, "Error: world not found", ":.*2248.*")
m.clearlog()

# Try to teleport without being at exit
m.send(c1a, "WORLD teleport forest")
m.expect(c1a, "Error: not at exit", ":.*2249.*")
m.clearlog()
print()

# Test 11: Boundary hit sequences
print("[TEST] Rapid boundary hit sequences")
# Move to boundary and try multiple boundary hits
for i in range(5):
    m.send(c1a, "MOVE north")
    resp = m.expect(c1a, f"Boundary hit {i+1}", ":.*2210.*|:.*2243.*")
    if ":.*2243.*" in str(resp):
        log_info(f"Boundary hit at attempt {i+1}")
        break

# Try hitting boundary multiple times
for i in range(3):
    m.send(c1a, "MOVE north")
    m.expect(c1a, f"Boundary hit {i+1}", ":.*2243.*")
m.clearlog()
print()

# Test 12: User mode edge cases
print("[TEST] User mode edge cases")
# Try to set world mode when not in world
m.send(c1a, "WORLD part")
m.expect(c1a, "World part success", ":.*2201.*")
m.expect(c1a, "User mode -y removed", "MODE.*-y")
m.clearlog()

# Try to join world again
m.send(c1a, "WORLD join")
m.expect(c1a, "World rejoin success", ":.*2200.*")
m.expect(c1a, "User mode +y set", "MODE.*\\+y")
m.clearlog()
print()

# Test 13: Message tag edge cases
print("[TEST] Message tag edge cases")
# Verify message tags are present on valid operations
m.send(c1a, "MOVE south")
m.expect(c1a, "Move success", ":.*2210.*")
m.expect(c1a, "Location tag present", "@world/location=")
m.expect(c1a, "Direction tag present", "@world/direction=")
m.clearlog()

m.send(c1a, "FACE west")
m.expect(c1a, "Face success", ":.*2211.*")
m.expect(c1a, "Location tag present", "@world/location=")
m.expect(c1a, "Direction tag present", "@world/direction=")
m.clearlog()
print()

# Test 14: Persistence edge cases
print("[TEST] Persistence edge cases")
# Save current state
m.send(c1a, "WORLD save")
m.expect(c1a, "Save success", ":.*2250.*")
m.clearlog()

# Part and rejoin to test persistence
m.send(c1a, "WORLD part")
m.expect(c1a, "World part success", ":.*2201.*")
m.clearlog()

m.send(c1a, "WORLD join")
m.expect(c1a, "World rejoin success", ":.*2200.*")
# Position should be restored
m.send(c1a, "WORLD show")
m.expect(c1a, "Position restored", ":.*2202.*")
m.clearlog()
print()

# Test 15: Stress test with many operations
print("[TEST] Stress test with many operations")
log_info("Testing stress scenarios")

# Many rapid operations
for i in range(10):
    directions = ["north", "south", "east", "west"]
    direction = directions[i % 4]
    
    m.send(c1a, f"MOVE {direction}")
    m.expect(c1a, f"Stress move {i+1}", ":.*2210.*|:.*2244.*")
    
    if ":.*2244.*" in str(m.last_response):  # Rate limit hit
        log_info(f"Rate limit hit during stress test at operation {i+1}")
        break

m.clearlog()
print()

# Test 16: Error recovery
print("[TEST] Error recovery")
# After hitting rate limit, wait and try again
time.sleep(2)  # Wait for rate limit to reset

m.send(c1a, "MOVE north")
m.expect(c1a, "Move after rate limit reset", ":.*2210.*")
m.clearlog()
print()

# Test 17: Multiple world channels
print("[TEST] Multiple world channels")
# Join another world channel
m.send(c1a, "JOIN #forest")
m.clearlog()

# Should be able to join forest world
m.send(c1a, "WORLD join")
m.expect(c1a, "Forest world join", ":.*2200.*")
m.clearlog()

# Show forest world info
m.send(c1a, "WORLD show")
m.expect(c1a, "Forest world info", ":.*2202.*")
m.clearlog()

# Return to spawn
m.send(c1a, "JOIN #spawn")
m.clearlog()
print()

# Test 18: Final edge case verification
print("[TEST] Final edge case verification")
# Verify all users are still functional
m.send(c1a, "WORLD show")
m.expect(c1a, "Final c1a world info", ":.*2202.*")

m.send(c1b, "WORLD show")
m.expect(c1b, "Final c1b world info", ":.*2202.*")

m.send(c1c, "WORLD show")
m.expect(c1c, "Final c1c world info", ":.*2202.*")

m.clearlog()
print()

print("=" * 60)
print("All edge case tests completed successfully!")
print("=" * 60)

def log_info(message):
    """Log informational messages"""
    print(f"[LOG] {message}")

def log_edge_case(scenario, expected, actual):
    """Log edge case results"""
    print(f"[EDGE] {scenario}: expected={expected}, actual={actual}")
