#!/usr/bin/python3
"""
World Module - Boundary tests
Tests movement boundaries, position validation, and edge cases
"""

import irctestframework.irctest

m = irctestframework.irctest.IrcTest()
# All clients must be on the same server for world to work
c1a = m.new('c1a')
c1b = m.new('c1b')
m.connect()

# Setup: Request capability and create world channel
m.send(c1a, "CAP REQ :world/features")
# Check if capability is available (ACK) or not (NAK)
resp = m.expect(c1a, "Capability response", ".*ACK.*world/features|.*NAK.*world/features")
if "NAK" in str(resp):
    print("SKIP: World module not loaded - capability NAK'd")
    print("All boundary tests skipped - module not available")
    exit(0)
m.clearlog()

m.send(c1b, "CAP REQ :world/features")
m.expect(c1b, "Capability acknowledged", ".*ACK.*world/features")
m.clearlog()

m.send(c1a, "JOIN #spawn")
m.clearlog()

m.send(c1b, "JOIN #spawn")
m.clearlog()

# Test 1: WORLD join sets initial position at respawn
print("[TEST] Initial position at respawn")
m.send(c1a, "WORLD join")
m.expect(c1a, "World join success", ":.*2200.*")
m.clearlog()
print()

# Test 2: Move within valid bounds
print("[TEST] Move within valid bounds")
m.send(c1a, "MOVE north")
m.expect(c1a, "Move success", ":.*2210.*")
m.clearlog()

m.send(c1a, "MOVE north")
m.expect(c1a, "Move success", ":.*2210.*")
m.clearlog()

m.send(c1a, "MOVE east")
m.expect(c1a, "Move success", ":.*2210.*")
m.clearlog()
print()

# Test 3: Move to edge of map (west boundary)
print("[TEST] Move to west boundary")
# Move all the way west
for i in range(10):
    m.send(c1a, "MOVE west")
    m.expect(c1a, "Move success", ":.*2210.*")
    m.clearlog()
print()

# Test 4: Attempt move outside west boundary
print("[TEST] Attempt move outside west boundary")
m.send(c1a, "MOVE west")
m.expect(c1a, "Out of bounds error", ":.*2242.*")
m.clearlog()
print()

# Test 5: Reset position and move to east boundary
print("[TEST] Move to east boundary")
m.send(c1a, "WORLD part")
m.clearlog()

m.send(c1a, "WORLD join")
m.expect(c1a, "World join success", ":.*2200.*")
m.clearlog()

# Move all the way east
for i in range(10):
    m.send(c1a, "MOVE east")
    m.expect(c1a, "Move success", ":.*2210.*")
    m.clearlog()
print()

# Test 6: Attempt move outside east boundary
print("[TEST] Attempt move outside east boundary")
m.send(c1a, "MOVE east")
m.expect(c1a, "Out of bounds error", ":.*2242.*")
m.clearlog()
print()

# Test 7: Move to north boundary
print("[TEST] Move to north boundary")
m.send(c1a, "WORLD part")
m.clearlog()

m.send(c1a, "WORLD join")
m.expect(c1a, "World join success", ":.*2200.*")
m.clearlog()

# Move all the way north
for i in range(10):
    m.send(c1a, "MOVE north")
    m.expect(c1a, "Move success", ":.*2210.*")
    m.clearlog()
print()

# Test 8: Attempt move outside north boundary
print("[TEST] Attempt move outside north boundary")
m.send(c1a, "MOVE north")
m.expect(c1a, "Out of bounds error", ":.*2242.*")
m.clearlog()
print()

# Test 9: Move to south boundary
print("[TEST] Move to south boundary")
m.send(c1a, "WORLD part")
m.clearlog()

m.send(c1a, "WORLD join")
m.expect(c1a, "World join success", ":.*2200.*")
m.clearlog()

# Move all the way south
for i in range(10):
    m.send(c1a, "MOVE south")
    m.expect(c1a, "Move success", ":.*2210.*")
    m.clearlog()
print()

# Test 10: Attempt move outside south boundary
print("[TEST] Attempt move outside south boundary")
m.send(c1a, "MOVE south")
m.expect(c1a, "Out of bounds error", ":.*2242.*")
m.clearlog()
print()

# Test 11: Position tracking across multiple moves
print("[TEST] Position tracking")
m.send(c1a, "WORLD part")
m.clearlog()

m.send(c1a, "WORLD join")
m.expect(c1a, "World join success", ":.*2200.*")
m.clearlog()

# Move in a pattern
m.send(c1a, "MOVE north")
m.expect(c1a, "Move success", ":.*2210.*")
m.clearlog()

m.send(c1a, "MOVE east")
m.expect(c1a, "Move success", ":.*2210.*")
m.clearlog()

m.send(c1a, "MOVE south")
m.expect(c1a, "Move success", ":.*2210.*")
m.clearlog()

m.send(c1a, "MOVE west")
m.expect(c1a, "Move success", ":.*2210.*")
m.clearlog()
print()

# Test 12: FACE does not change position
print("[TEST] FACE does not change position")
m.send(c1a, "WORLD show")
m.expect(c1a, "World info", ":.*2202.*")
m.clearlog()

m.send(c1a, "FACE north")
m.expect(c1a, "Face success", ":.*2211.*")
m.clearlog()

m.send(c1a, "FACE east")
m.expect(c1a, "Face success", ":.*2211.*")
m.clearlog()

m.send(c1a, "FACE south")
m.expect(c1a, "Face success", ":.*2211.*")
m.clearlog()

m.send(c1a, "FACE west")
m.expect(c1a, "Face success", ":.*2211.*")
m.clearlog()

# Position should still be at respawn (we moved north-east-south-west)
m.send(c1a, "WORLD show")
m.expect(c1a, "World info", ":.*2202.*")
m.clearlog()
print()

# Test 13: Corner boundaries
print("[TEST] Corner boundaries")
m.send(c1a, "WORLD part")
m.clearlog()

m.send(c1a, "WORLD join")
m.expect(c1a, "World join success", ":.*2200.*")
m.clearlog()

# Move to northwest corner
for i in range(10):
    m.send(c1a, "MOVE north")
    m.expect(c1a, "Move success", ":.*2210.*")
    m.clearlog()

for i in range(10):
    m.send(c1a, "MOVE west")
    m.expect(c1a, "Move success", ":.*2210.*")
    m.clearlog()

# Try to move out of northwest corner
m.send(c1a, "MOVE north")
m.expect(c1a, "Out of bounds error", ":.*2242.*")
m.clearlog()

m.send(c1a, "MOVE west")
m.expect(c1a, "Out of bounds error", ":.*2242.*")
m.clearlog()
print()

# Test 14: Multiple users position independently
print("[TEST] Multiple users position independently")
m.send(c1b, "WORLD join")
m.expect(c1b, "World join success", ":.*2200.*")
m.clearlog()

# c1a moves
m.send(c1a, "MOVE south")
m.expect(c1a, "Move success", ":.*2210.*")
m.clearlog()

# c1b moves
m.send(c1b, "MOVE east")
m.expect(c1b, "Move success", ":.*2210.*")
m.clearlog()

# c1a moves again
m.send(c1a, "MOVE south")
m.expect(c1a, "Move success", ":.*2210.*")
m.clearlog()

# Both should be in world independently
m.send(c1a, "WORLD show")
m.expect(c1a, "World info", ":.*2202.*")
m.clearlog()

m.send(c1b, "WORLD show")
m.expect(c1b, "World info", ":.*2202.*")
m.clearlog()
print()

# Test 15: Diagonal boundary attempts
print("[TEST] Diagonal boundary attempts")
print(f"[LOG] Testing diagonal boundary scenarios")

# Try to move diagonally by combining movements
m.send(c1a, "MOVE north")
m.expect(c1a, "North move", ":.*2210.*")
m.send(c1a, "MOVE east")
m.expect(c1a, "East move", ":.*2210.*")
# Now at northeast corner, try to move further
m.send(c1a, "MOVE north")
resp = m.expect(c1a, "North boundary test", ":.*2210.*|:.*2243.*")
if ":.*2243.*" in str(resp):
    print(f"[LOG] North boundary hit at diagonal position")
m.clearlog()

m.send(c1a, "MOVE east")
resp = m.expect(c1a, "East boundary test", ":.*2210.*|:.*2243.*")
if ":.*2243.*" in str(resp):
    print(f"[LOG] East boundary hit at diagonal position")
m.clearlog()
print()

# Test 16: Rapid boundary hit sequences
print("[TEST] Rapid boundary hit sequences")
print(f"[LOG] Testing rapid boundary hit scenarios")

# Move to boundary and try multiple boundary hits rapidly
for i in range(5):
    m.send(c1a, "MOVE north")
    resp = m.expect(c1a, f"Rapid boundary hit {i+1}", ":.*2210.*|:.*2243.*")
    if ":.*2243.*" in str(resp):
        print(f"[LOG] Boundary hit at rapid attempt {i+1}")
        # Try hitting boundary multiple times
        for j in range(3):
            m.send(c1a, "MOVE north")
            m.expect(c1a, f"Boundary hit {j+1}", ":.*2243.*")
        break
m.clearlog()
print()

# Test 17: Boundary messages include proper location tags
print("[TEST] Boundary messages include proper location tags")
print(f"[LOG] Testing boundary message tags")

# Move to boundary and verify tags are present
m.send(c1a, "MOVE north")
resp = m.expect(c1a, "Boundary move with tags", ":.*2210.*|:.*2243.*")

# Verify location tag is present even on boundary hit
if "@world/location=" in str(resp):
    print(f"[LOG] Location tag present in boundary response")
else:
    print(f"[LOG] Location tag missing in boundary response")

# Verify direction tag is present
if "@world/direction=" in str(resp):
    print(f"[LOG] Direction tag present in boundary response")
else:
    print(f"[LOG] Direction tag missing in boundary response")

m.clearlog()
print()

# Test 18: Multiple users at boundaries
print("[TEST] Multiple users at boundaries")
print(f"[LOG] Testing multiple users at boundaries")

# Move both users to different boundaries
m.send(c1a, "MOVE north")
m.expect(c1a, "c1a north move", ":.*2210.*|:.*2243.*")

m.send(c1b, "MOVE south")
m.expect(c1b, "c1b south move", ":.*2210.*|:.*2243.*")

# Each should see the other's movement
m.expect(c1a, "c1a sees c1b move", "WORLD.*MOVE")
m.expect(c1b, "c1b sees c1a move", "WORLD.*MOVE")

log_info("Multiple users handled boundaries appropriately")
m.clearlog()
print()

# Test 19: Boundary with different world sizes
print("[TEST] Boundary with different world sizes")
print(f"[LOG] Testing boundaries with different world configurations")

# Test with small world (5x5)
m.send(c1a, "JOIN #test_small")
m.clearlog()

m.send(c1a, "WORLD join")
m.expect(c1a, "Small world join", ":.*2200.*")
m.clearlog()

# Try to move beyond small world boundaries
for i in range(8):  # More than 5x5 size
    m.send(c1a, "MOVE north")
    resp = m.expect(c1a, f"Small world move {i+1}", ":.*2210.*|:.*2243.*")
    if ":.*2243.*" in str(resp):
        print(f"[LOG] Small world boundary hit at move {i+1}")
        break

m.clearlog()

# Return to spawn world
m.send(c1a, "JOIN #spawn")
m.clearlog()
print()

# Test 20: Final boundary verification
print("[TEST] Final boundary verification")
print(f"[LOG] Final boundary test verification")

# Verify all users can still move after boundary tests
m.send(c1a, "WORLD show")
m.expect(c1a, "Final c1a world info", ":.*2202.*")

m.send(c1b, "WORLD show")
m.expect(c1b, "Final c1b world info", ":.*2202.*")

# Perform final movement to verify functionality
m.send(c1a, "MOVE south")
m.expect(c1a, "Final c1a move", ":.*2210.*")

m.send(c1b, "MOVE north")
m.expect(c1b, "Final c1b move", ":.*2210.*")

log_info("All boundary tests completed successfully")
m.clearlog()
print()

print("All boundary tests completed successfully!")

def log_info(message):
    """Log informational messages"""
    print(f"[LOG] {message}")

